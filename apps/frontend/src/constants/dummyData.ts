export const dummyPosts = [
  {
    id: 1,
    title: "The Power of Clean Code in Modern Development",
    excerpt:
      "Explore the importance of writing clean, readable code and how it impacts your software's long-term success.",
    slug: "clean-code-modern-dev",
    content: `Clean code isn't just about aesthetics — it's about building software that lasts. As projects scale, messy code leads to technical debt, slower velocity, and team frustration. Clean code is self-explanatory, well-organized, and easy to maintain. Practices like meaningful naming, modular architecture, and avoiding unnecessary complexity improve collaboration and reduce onboarding time. By embracing clean code, you create systems that are easier to debug, extend, and scale — ensuring that your codebase grows with your business, not against it.`,
  },
  {
    id: 2,
    title: "Why React Hooks Changed the Game",
    excerpt:
      "Hooks revolutionized React development — find out how and why you should master them.",
    slug: "react-hooks-explained",
    content: `React Hooks have completely transformed how developers build components. Before hooks, managing state and lifecycle in functional components was impossible. Hooks like \`useState\`, \`useEffect\`, and \`useContext\` enabled powerful logic reuse without wrapping components in classes. Hooks promote cleaner code, easier testing, and improved readability. Custom hooks further enhance abstraction, letting you separate logic from UI. Today, hooks are the standard — and understanding them deeply is essential for any serious React developer.`,
  },
  {
    id: 3,
    title: "Serverless Functions: Future of Backend?",
    excerpt:
      "A dive into serverless architecture and why it's gaining popularity among startups and enterprises.",
    slug: "serverless-future-backend",
    content: `Serverless functions allow developers to deploy backend logic without managing servers. With providers like AWS Lambda, Vercel, and Netlify Functions, you can build scalable APIs with zero infrastructure setup. They're cost-effective, auto-scaling, and great for event-driven applications. But they also come with cold starts, limited execution time, and debugging challenges. Despite these trade-offs, the simplicity and scalability of serverless functions make them an attractive option — especially for microservices, APIs, and rapid prototyping.`,
  },
  {
    id: 4,
    title: "Styling in 2025: Tailwind vs Vanilla CSS",
    excerpt:
      "Tailwind CSS has taken the frontend world by storm, but is it always the best choice?",
    slug: "tailwind-vs-css",
    content: `Tailwind CSS has revolutionized styling by enabling utility-first design with minimal custom CSS. Developers love its speed, flexibility, and ability to create fully responsive designs with just HTML classes. However, it has a learning curve and can clutter markup. On the other hand, Vanilla CSS remains powerful for small projects and custom animations. In 2025, choosing between Tailwind and vanilla CSS depends on your project size, team familiarity, and personal preference. Both have their place — and the best developers know when to use which.`,
  },
  {
    id: 5,
    title: "JavaScript Async Patterns Made Simple",
    excerpt:
      "Promises, async/await, and when to use them — a simple guide for modern JS devs.",
    slug: "async-js-patterns",
    content: `Asynchronous programming in JavaScript can be confusing, but mastering it is crucial for modern web development. Promises provide a cleaner way to handle async tasks than nested callbacks. \`async/await\` makes it even more readable, resembling synchronous code. The key is understanding how these patterns work under the hood — from the event loop to microtasks. Whether you’re fetching data, reading files, or delaying execution, knowing the right async pattern will make your code faster, cleaner, and more reliable.`,
  },
  {
    id: 6,
    title: "Top 5 VS Code Extensions for Productivity",
    excerpt:
      "Enhance your development workflow with these must-have VS Code extensions.",
    slug: "vscode-productivity",
    content: `VS Code has become the go-to editor for developers, and extensions make it even better. The top five picks for productivity are: 1) Prettier – auto-format your code instantly. 2) ESLint – catch bugs before runtime. 3) GitLens – visualize Git history and authorship. 4) Path Intellisense – auto-suggest file paths. 5) Tabnine or Copilot – AI-assisted code completion. These tools help automate repetitive tasks, improve code quality, and speed up your workflow — making you a better developer with less effort.`,
  },
  {
    id: 7,
    title: "Next.js App Router: Should You Switch?",
    excerpt:
      "Next.js 13+ introduced App Router — here's what you need to know before migrating.",
    slug: "nextjs-app-router",
    content: `The App Router introduced in Next.js 13 is a game-changer. With file-based routing, nested layouts, loading states, and server components built-in, it brings a new mental model for building apps. It enables better performance and more flexibility, but it’s not without its gotchas. If you're migrating from the Pages Router, expect breaking changes and a need to rethink architecture. That said, App Router is the future of Next.js — and adopting it early could future-proof your app.`,
  },
  {
    id: 8,
    title: "The Magic of Payload CMS Explained",
    excerpt:
      "Why Payload CMS is gaining traction among devs looking for flexibility and full control.",
    slug: "payload-cms-overview",
    content: `Payload CMS is a headless CMS that puts developers in full control. Unlike no-code solutions, Payload is code-first and extensible — built with TypeScript, Express, and MongoDB. It offers a customizable admin panel, powerful access control, and built-in auth. Features like localized content, custom fields, and rich media handling make it ideal for startups and agencies. Whether you’re building a blog, e-commerce platform, or SaaS dashboard, Payload gives you the flexibility to do it your way.`,
  },
  {
    id: 9,
    title: "How Supabase Became the Firebase Alternative",
    excerpt:
      "Supabase is taking over the backend-as-a-service space — here's what makes it great.",
    slug: "supabase-vs-firebase",
    content: `Supabase offers all the features developers love about Firebase — real-time databases, auth, and storage — but with open-source transparency and SQL power. Built on PostgreSQL, it gives devs full control over their data, relations, and security. The Supabase dashboard is intuitive, and the community is growing fast. Unlike Firebase, you can self-host Supabase or run it serverless. This combination of flexibility and modern tooling is why more teams are switching to Supabase in 2025.`,
  },
  {
    id: 10,
    title: "Building Scalable Blogs with Next.js",
    excerpt:
      "What it really takes to build and deploy a production-level blog using the latest stack.",
    slug: "scalable-blogs-nextjs",
    content: `Creating a scalable blog in Next.js requires more than just a beautiful UI. You need dynamic routing, static site generation (SSG), incremental static regeneration (ISR), and smart caching for performance. Combine this with CMS integration (like Payload or Sanity), SEO optimization, and global CSS support — and you’ve got a powerful publishing platform. Hosting on Vercel or Netlify ensures CI/CD and blazing-fast delivery. If you structure your blog well from the start, scaling it to thousands of posts will be seamless.`,
  },
];
